# 🚀 최적화 (Optimization)

웹 서비스의 성능을 개선하는 모든 행위를 의미합니다.

---

## 일반적인 웹 서비스 최적화 방법

1. **서버 응답 속도 개선**
2. **정적 파일 로딩 최적화**: 이미지, 폰트, 코드 파일 등
3. **불필요한 네트워크 요청 최소화**

---

## React 앱 내부 최적화 방법

1. 컴포넌트 내부의 **불필요한 연산 방지**
2. 컴포넌트 내부의 **불필요한 함수 재생성 방지**
3. 컴포넌트의 **불필요한 리렌더링 방지**

---

## 📝 `useMemo`란?

`useMemo`는 **메모이제이션(Memoization)** 기법을 활용해 **불필요한 연산을 최적화**하는 React 훅입니다.

### 💡 예시 코드

```jsx
const { totalCount, doneCount, notDoneCount } = useMemo(() => {
  console.log("getAnalyzedData 호출!");

  const totalCount = todos.length;
  const doneCount = todos.filter(todo => todo.isDone).length;
  const notDoneCount = totalCount - doneCount;

  return {
    totalCount,
    doneCount,
    notDoneCount,
  };
}, [todos]);
```

### 설명

* 간단한 Todo 앱에서 전체 투두 개수, 완료된 리스트 개수, 미완료 리스트 개수를 계산할 때,
* **리렌더링마다 매번 계산**하면 불필요한 연산이 발생함
* `useMemo`를 사용하면 **이전 계산값을 재사용**하여 최적화 가능
* 의존성 배열 `[todos]`에 투두 목록을 넣어, 목록이 변경될 때만 재계산되도록 설정

---

### ⚠️ 주의점

* 모든 연산에 `useMemo`를 사용하는 것은 **필요 없음**
* **계산 비용이 큰 연산**에 사용하면 효과적
* 의존성 배열 관리가 잘못되면 예상치 못한 동작 발생 가능

--------

## 📝 React.memo란?

* `React.memo`는 특정 컴포넌트를 **메모이제이션된(기억되는)** 컴포넌트로 감싸서 반환합니다.
* 메모이제이션 기준은 **props의 얕은 비교(Shallow Compare)** 입니다.
* 부모 컴포넌트가 리렌더링되더라도, **props가 변경되지 않았다면 해당 컴포넌트는 다시 리렌더링되지 않습니다.**

```javascript
const MemoizedComponent = memo(Component);
```

---

### 기본 사용 예시

```jsx
import { memo } from "react";

const Header = () => {
  return (
    <div className="Header">
      <h3>오늘은 </h3>
      <h1>{new Date().toDateString()}</h1>
    </div>
  );
};

export default memo(Header);
```

🔎 **설명**: `Header` 컴포넌트는 props를 받지 않지만, 부모 리렌더링의 영향을 받아 불필요하게 재렌더링될 수 있음 → `memo`로 감싸 자동 최적화.

---

### 📌 Props를 받는 컴포넌트에 memo 적용

```jsx
const TodoItem = ({
  id, isDone, content, date, onUpdate, onDelete
}) => {
  const onChangeCheckbox = () => {
    onUpdate(id);
  };

  const onClickDeleteButton = () => {
    onDelete(id);
  };

  return (
    <div className="TodoItem">
      <input
        onChange={onChangeCheckbox}
        readOnly
        checked={isDone}
        type="checkbox"
      />
      <div className="content">{content}</div>
      <div className="date">
        {new Date(date).toLocaleDateString()}
      </div>
      <button onClick={onClickDeleteButton}>삭제</button>
    </div>
  );
};

export default memo(TodoItem);
```

---

### ⚠️ memo의 얕은 비교 문제

`memo`의 props 비교 방식은 **얕은 비교(Shallow Compare)** 입니다.

따라서 아래 같은 **참조 타입(객체·함수)** 은 값이 같아도 매 렌더마다 **다른 주소값** 을 가지므로 무조건 변경된 것으로 판단됩니다.

예:

* `onUpdate`
* `onDelete`

➡️ memo는 이 값들이 "바뀌었다고 판단"하여 리렌더링을 발생시킴.

---

### 🛠️ 해결 방법 1: `useCallback` 사용하기

함수가 리렌더링마다 새로 생성되지 않도록 함.

```jsx
const onUpdate = useCallback((id) => {
  ...
}, []);
```

이렇게 하면 memo가 "동일한 함수"라고 인식해 리렌더링을 방지할 수 있음.

---

### 🛠️ 해결 방법 2: `React.memo`의 커스텀 비교 함수 사용

두 번째 인수로 **props 비교 함수를 직접 전달**할 수 있음.

```jsx
export default memo(TodoItem, (prevProps, nextProps) => {
  if (prevProps.id !== nextProps.id) return false;
  if (prevProps.isDone !== nextProps.isDone) return false;
  if (prevProps.content !== nextProps.content) return false;
  if (prevProps.date !== nextProps.date) return false;

  return true; // props 변경 없음 → 리렌더링 X
});
```

#### 🔍 동작 방식

* `true` 반환 → props가 같음 → **리렌더링 방지**
* `false` 반환 → props가 바뀜 → **리렌더링 발생**

---

### 요약

* `React.memo`는 props를 기준으로 컴포넌트를 메모이제이션해 **불필요한 리렌더링을 방지**.
* 기본 비교는 얕은 비교이므로 **함수/객체 props는 매번 다르게 판단됨**.
* 이를 해결하려면

  1. **useCallback으로 함수 메모이제이션**
  2. **memo의 커스텀 비교 함수 제공**
* 비교 함수는 props가 많아지면 복잡해지므로 상황에 따라 적절히 선택해야 함 

---
# 📝 useCallback 정리

`useCallback`은 **함수를 메모이제이션하여 불필요한 함수 재생성을 방지**하는 React 훅입니다.

---

## useCallback 기본 형태

```jsx
const onDelete = useCallback((targetId) => {
  dispatch({
    type: "DELETE",
    targetId: targetId,
  });
}, []);
```

* 첫 번째 인수: 메모이제이션할 **콜백 함수**
* 두 번째 인수: 의존성 배열 → 배열이 변경될 때만 함수가 다시 생성됨

---

## 왜 useCallback을 사용할까?

React 컴포넌트는 리렌더링될 때 **내부에서 선언한 모든 함수가 새롭게 생성**됩니다.

이때,

* 해당 함수를 props로 전달하면 자식 컴포넌트는 "props가 변경되었다"고 판단해 불필요하게 리렌더링하게 됨
* useCallback을 사용하면 이전에 생성한 함수를 재사용하여 **불필요한 리렌더링을 방지**할 수 있음

→ 특히 `React.memo`와 함께 사용할 때 더 큰 효과를 발휘함

---

## useCallback을 언제 사용하는가?

> 최적화는 **항상 필요한 순간에만, 기능을 완성한 뒤에** 진행하는 것이 중요하다.

### 1. 언제 최적화해야 하나?

* 기능이 정상적으로 동작하는 버전을 먼저 완성한 뒤
* 불필요한 리렌더링이나 성능 저하가 눈에 띄는 부분에 적용

### 2. 어떤 것을 최적화해야 하나?

* **모든 함수를 useCallback으로 감싸면 오히려 역효과**가 날 수 있음
* 오직 아래 상황에서만 사용 권장

  * 자식 컴포넌트가 `React.memo`로 감싸져 있을 때
  * 동일한 콜백 함수가 자주 재생성되어 성능 저하가 우려될 때
  * 복잡한 연산을 수행하는 이벤트 함수를 메모이제이션하고 싶을 때

---

## 📝 요약

* `useCallback`은 **함수를 메모이제이션하는 최적화 도구**
* 목적: 컴포넌트 리렌더링 시 **함수가 재생성되지 않도록** 방지
* 사용 시점: 기능 완성 후 **실제 필요한 부분만 최적화**
* 조합: `React.memo` + `useCallback` 조합이 효과적

